<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pointers - C++ Learn The Right Way</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ Learn The Right Way</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="c-pointers--dynamic-memory-allocation---complete-tutorial"><a class="header" href="#c-pointers--dynamic-memory-allocation---complete-tutorial">C++ Pointers &amp; Dynamic Memory Allocation - Complete Tutorial</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#1-introduction-to-pointers">Introduction to Pointers</a></li>
<li><a href="#2-how-dereferencing-works">How Dereferencing Works</a></li>
<li><a href="#3-dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
<li><a href="#4-void-pointers">Void Pointers</a></li>
<li><a href="#5-pointer-size">Pointer Size</a></li>
<li><a href="#6-arrays-and-pointers">Arrays and Pointers</a></li>
<li><a href="#7-const-pointers-variations">Const Pointers Variations</a></li>
<li><a href="#8-breaking-constantness">Breaking Constantness</a></li>
<li><a href="#9-placement-new-operator">Placement New Operator</a></li>
<li><a href="#10-best-practices">Best Practices</a></li>
<li><a href="#11-common-bugs">Common Bugs</a></li>
</ol>
<hr />
<h2 id="1-introduction-to-pointers"><a class="header" href="#1-introduction-to-pointers">1. Introduction to Pointers</a></h2>
<h3 id="c-pointer-basics"><a class="header" href="#c-pointer-basics">C++ Pointer Basics</a></h3>
<p>A <strong>pointer</strong> is a variable that stores the memory address of another variable.</p>
<pre><code class="language-cpp">int value = 42;
int* ptr = &amp;value;  // ptr stores the address of value

std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;           // Output: 42
std::cout &lt;&lt; "Address of value: " &lt;&lt; &amp;value &lt;&lt; std::endl;  // Output: 0x7ffc12345678
std::cout &lt;&lt; "Pointer ptr: " &lt;&lt; ptr &lt;&lt; std::endl;       // Output: 0x7ffc12345678
std::cout &lt;&lt; "Dereferenced ptr: " &lt;&lt; *ptr &lt;&lt; std::endl; // Output: 42
</code></pre>
<p><strong>Key Operators:</strong></p>
<ul>
<li><code>&amp;</code> (address-of operator): Gets the memory address of a variable</li>
<li><code>*</code> (dereference operator): Accesses the value at the address stored in the pointer</li>
</ul>
<h3 id="real-life-analogy-home-addresses"><a class="header" href="#real-life-analogy-home-addresses">Real-Life Analogy: Home Addresses</a></h3>
<p>Think of computer memory like a street with houses. Each house has:</p>
<ul>
<li><strong>An address</strong> (like "123 Main Street") - this is the memory address</li>
<li><strong>Contents inside</strong> (furniture, people, etc.) - this is the actual data</li>
<li><strong>A mailbox with the address written on it</strong> - this is the pointer</li>
</ul>
<pre><code>Real Life:                          Computer Memory:
┌─────────────────────────┐        ┌─────────────────────────┐
│  123 Main Street        │        │  Memory Address: 0x1000 │
│  ┌─────────────────┐    │        │  ┌─────────────────┐    │
│  │  John's House   │    │        │  │  Value: 42      │    │
│  │  (The actual    │    │        │  │  (The actual    │    │
│  │   person/data)  │    │        │  │   data)         │    │
│  └─────────────────┘    │        │  └─────────────────┘    │
└─────────────────────────┘        └─────────────────────────┘

Your Friend's Note:                 Your Pointer Variable:
┌─────────────────────────┐        ┌─────────────────────────┐
│ "John lives at          │        │  int* ptr = 0x1000;     │
│  123 Main Street"       │        │                         │
│  (The address, not      │        │  (The address, not      │
│   the person!)          │        │   the value!)           │
└─────────────────────────┘        └─────────────────────────┘
</code></pre>
<p><strong>Key Insights from the Analogy:</strong></p>
<ol>
<li>
<p><strong>Address vs Contents:</strong></p>
<ul>
<li>When someone gives you an address "123 Main Street", they're not giving you the house or John - just the location</li>
<li>When a pointer stores <code>0x1000</code>, it's not storing the value <code>42</code> - just the location</li>
</ul>
</li>
<li>
<p><strong>Using the Address (Dereferencing):</strong></p>
<ul>
<li>If you want to visit John, you go to "123 Main Street" and knock on the door</li>
<li>If you want the value, you dereference <code>*ptr</code> (go to address <code>0x1000</code> and get the data)</li>
</ul>
</li>
<li>
<p><strong>Multiple References:</strong></p>
<ul>
<li>You can have many notes with the same address "123 Main Street"</li>
<li>You can have many pointers to the same memory address</li>
</ul>
</li>
<li>
<p><strong>Changing the Address:</strong></p>
<ul>
<li>You can update your note to point to a different house: <del>123 Main Street</del> → 456 Oak Avenue</li>
<li>You can change what a pointer points to: <code>ptr = &amp;another_variable;</code></li>
</ul>
</li>
<li>
<p><strong>nullptr is like "No Address":</strong></p>
<ul>
<li>A blank note with no address written on it</li>
<li>You can't visit a house if you don't have an address!</li>
</ul>
</li>
</ol>
<h3 id="extending-the-analogy"><a class="header" href="#extending-the-analogy">Extending the Analogy:</a></h3>
<pre><code class="language-cpp">// Real Life                          // Code
int john_age = 25;                    // John (age 25) lives at 123 Main St
int* address_note = &amp;john_age;        // Write down John's address on a note

std::cout &lt;&lt; address_note;            // Read the note: "123 Main Street"
std::cout &lt;&lt; *address_note;           // Go to that address, find John: age 25

*address_note = 26;                   // Go to 123 Main St, update John's age to 26
// john_age is now 26!                // John's actual age changed!

int mary_age = 30;                    // Mary (age 30) lives at 456 Oak Ave
address_note = &amp;mary_age;             // Update the note to Mary's address
// Now the note points to Mary's house instead of John's house
</code></pre>
<h3 id="what-happens-without-pointers"><a class="header" href="#what-happens-without-pointers">What Happens Without Pointers?</a></h3>
<pre><code class="language-cpp">// Without pointer (making a copy)    // Real Life Analogy
int john_age = 25;                    // John is 25 years old
int copy_of_age = john_age;          // You write "25" on a paper (copy)

copy_of_age = 26;                     // You change the paper to "26"
// john_age is STILL 25!              // But John is STILL 25 years old!
                                      // You only changed your copy

// With pointer (reference)           // Real Life Analogy
int john_age = 25;                    // John is 25 years old
int* ptr = &amp;john_age;                // You write down John's address

*ptr = 26;                            // Go to John's house and change his age
// john_age is NOW 26!                // John himself is now 26!
</code></pre>
<h3 id="why-pointers-are-useful"><a class="header" href="#why-pointers-are-useful">Why Pointers Are Useful:</a></h3>
<ol>
<li>
<p><strong>Efficiency (Sending Just the Address):</strong></p>
<pre><code>Real Life: Instead of copying an entire book to send to someone,
           you send them the library address and shelf number

Code: Instead of copying 1GB of data, you pass a pointer (8 bytes)
</code></pre>
</li>
<li>
<p><strong>Shared Access:</strong></p>
<pre><code>Real Life: Multiple people can have the same address and visit
           the same house

Code: Multiple pointers can reference the same data
</code></pre>
</li>
<li>
<p><strong>Dynamic Allocation:</strong></p>
<pre><code>Real Life: Building a new house when you need it (new construction)
           and tearing it down when done (demolition)

Code: Allocating memory with 'new' when needed
      and freeing it with 'delete' when done
</code></pre>
</li>
</ol>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="2-how-dereferencing-works"><a class="header" href="#2-how-dereferencing-works">2. How Dereferencing Works</a></h2>
<p>Dereferencing is the process of accessing the value stored at the memory address held by a pointer.</p>
<h3 id="step-by-step-process"><a class="header" href="#step-by-step-process">Step-by-Step Process:</a></h3>
<pre><code>Memory Layout:
┌─────────────┬──────────┬─────────────┐
│  Address    │   Data   │  Variable   │
├─────────────┼──────────┼─────────────┤
│ 0x1000      │    42    │   value     │
│ 0x1004      │  0x1000  │   ptr       │
└─────────────┴──────────┴─────────────┘
</code></pre>
<p><strong>When you dereference <code>*ptr</code>:</strong></p>
<ol>
<li><strong>Step 1:</strong> CPU reads the pointer variable <code>ptr</code> → Gets address <code>0x1000</code></li>
<li><strong>Step 2:</strong> CPU goes to memory location <code>0x1000</code></li>
<li><strong>Step 3:</strong> Uses the data type (<code>int</code>) to determine how many bytes to read (4 bytes for int)</li>
<li><strong>Step 4:</strong> Reads 4 bytes starting from <code>0x1000</code> → Gets value <code>42</code></li>
<li><strong>Step 5:</strong> Returns the value <code>42</code></li>
</ol>
<h3 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation:</a></h3>
<pre><code>int value = 42;        // Located at address 0x1000
int* ptr = &amp;value;     // ptr contains 0x1000

Memory View:
┌──────────────────────────────────────┐
│  Address: 0x1000                     │
│  ┌────┬────┬────┬────┐               │
│  │ 42 │ 00 │ 00 │ 00 │  (4 bytes)    │ ← value
│  └────┴────┴────┴────┘               │
└──────────────────────────────────────┘
        ↑
        │
    ┌───┴────┐
    │  ptr   │ (stores 0x1000)
    └────────┘

*ptr operation:
1. Read ptr       → 0x1000
2. Go to 0x1000   → Find memory location
3. Type is int    → Read 4 bytes
4. Fetch data     → 42
</code></pre>
<h3 id="example-with-different-data-types"><a class="header" href="#example-with-different-data-types">Example with Different Data Types:</a></h3>
<pre><code class="language-cpp">// Different types require different byte reads
char c = 'A';        // 1 byte
short s = 1000;      // 2 bytes
int i = 50000;       // 4 bytes
long long ll = 1e15; // 8 bytes
double d = 3.14;     // 8 bytes

char* ptr_c = &amp;c;         // When dereferencing, read 1 byte
short* ptr_s = &amp;s;        // When dereferencing, read 2 bytes
int* ptr_i = &amp;i;          // When dereferencing, read 4 bytes
long long* ptr_ll = &amp;ll;  // When dereferencing, read 8 bytes
double* ptr_d = &amp;d;       // When dereferencing, read 8 bytes
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="3-dynamic-memory-allocation"><a class="header" href="#3-dynamic-memory-allocation">3. Dynamic Memory Allocation</a></h2>
<p>Dynamic memory is allocated on the <strong>heap</strong> at runtime using <code>new</code> and must be manually freed using <code>delete</code>.</p>
<h3 id="using-new-and-delete"><a class="header" href="#using-new-and-delete">Using <code>new</code> and <code>delete</code></a></h3>
<pre><code class="language-cpp">// Single object allocation
int* ptr = new int;        // Allocate memory for one int
*ptr = 100;                // Assign value
std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
delete ptr;                // Free memory
ptr = nullptr;             // Good practice: nullify after delete

// Allocate with initialization
int* ptr2 = new int(42);   // Allocate and initialize to 42
delete ptr2;

// Array allocation
int* arr = new int[5];     // Allocate array of 5 ints
arr[0] = 10;
arr[1] = 20;
delete[] arr;              // Must use delete[] for arrays
arr = nullptr;
</code></pre>
<h3 id="memory-layout-stack-vs-heap"><a class="header" href="#memory-layout-stack-vs-heap">Memory Layout: Stack vs Heap</a></h3>
<pre><code>Stack (automatic storage):          Heap (dynamic storage):
┌─────────────────────┐            ┌─────────────────────┐
│  int x = 10;        │            │  new int(42)        │
│  [cleaned up auto]  │            │  [manual cleanup]   │
│                     │            │                     │
│  Limited size       │            │  Large size         │
│  Fast access        │            │  Slower access      │
│  LIFO structure     │            │  Fragmented         │
└─────────────────────┘            └─────────────────────┘
</code></pre>
<h3 id="key-differences"><a class="header" href="#key-differences">Key Differences:</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Stack</th><th>Heap</th></tr></thead><tbody>
<tr><td>Allocation</td><td>Automatic</td><td>Manual (new)</td></tr>
<tr><td>Deallocation</td><td>Automatic</td><td>Manual (delete)</td></tr>
<tr><td>Size</td><td>Limited (~1-8MB)</td><td>Large (GB)</td></tr>
<tr><td>Speed</td><td>Faster</td><td>Slower</td></tr>
<tr><td>Lifetime</td><td>Scope-based</td><td>Until delete</td></tr>
</tbody></table>
</div>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="4-void-pointers"><a class="header" href="#4-void-pointers">4. Void Pointers</a></h2>
<p>A <code>void*</code> is a <strong>generic pointer</strong> that can point to any data type but cannot be dereferenced directly.</p>
<pre><code class="language-cpp">void* void_ptr;
int x = 42;
double y = 3.14;
char c = 'A';

// void* can point to any type
void_ptr = &amp;x;
void_ptr = &amp;y;
void_ptr = &amp;c;

// ERROR: Cannot dereference void*
// std::cout &lt;&lt; *void_ptr &lt;&lt; std::endl;  // Compiler error!

// Must cast to specific type before dereferencing
void_ptr = &amp;x;
int value = *(static_cast&lt;int*&gt;(void_ptr));  // OK: Cast then dereference
std::cout &lt;&lt; value &lt;&lt; std::endl;  // Output: 42
</code></pre>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases:</a></h3>
<pre><code class="language-cpp">// 1. Generic memory allocation functions
void* malloc(size_t size);  // C-style allocation returns void*

// 2. Generic callback functions
void process_data(void* data, void (*callback)(void*)) {
    callback(data);
}

// 3. Type-erased storage
void* user_data = new UserData();
// Later cast back: auto* ud = static_cast&lt;UserData*&gt;(user_data);
</code></pre>
<h3 id="important-notes"><a class="header" href="#important-notes">Important Notes:</a></h3>
<ul>
<li>Cannot perform pointer arithmetic on <code>void*</code></li>
<li>Cannot dereference without casting</li>
<li>Type safety is programmer's responsibility</li>
<li>Modern C++ prefers templates over void pointers</li>
</ul>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="5-pointer-size"><a class="header" href="#5-pointer-size">5. Pointer Size</a></h2>
<p>The size of a pointer depends on the <strong>system architecture</strong>, not the data type it points to.</p>
<pre><code class="language-cpp">// On 64-bit systems: all pointers are 8 bytes
// On 32-bit systems: all pointers are 4 bytes

char* ptr_char;
int* ptr_int;
double* ptr_double;
long long* ptr_ll;
void* ptr_void;

std::cout &lt;&lt; "Size of char*:      " &lt;&lt; sizeof(ptr_char) &lt;&lt; std::endl;    // 8 on 64-bit
std::cout &lt;&lt; "Size of int*:       " &lt;&lt; sizeof(ptr_int) &lt;&lt; std::endl;     // 8 on 64-bit
std::cout &lt;&lt; "Size of double*:    " &lt;&lt; sizeof(ptr_double) &lt;&lt; std::endl;  // 8 on 64-bit
std::cout &lt;&lt; "Size of long long*: " &lt;&lt; sizeof(ptr_ll) &lt;&lt; std::endl;      // 8 on 64-bit
std::cout &lt;&lt; "Size of void*:      " &lt;&lt; sizeof(ptr_void) &lt;&lt; std::endl;    // 8 on 64-bit

// All output: 8 bytes on 64-bit system
</code></pre>
<h3 id="why-all-pointers-are-the-same-size"><a class="header" href="#why-all-pointers-are-the-same-size">Why All Pointers Are The Same Size:</a></h3>
<pre><code>A pointer is just a memory address:

32-bit system:
  Address space: 0x00000000 to 0xFFFFFFFF
  Pointer size: 4 bytes (32 bits)
  
64-bit system:
  Address space: 0x0000000000000000 to 0xFFFFFFFFFFFFFFFF
  Pointer size: 8 bytes (64 bits)

The data type tells the compiler:
  - How many bytes to read when dereferencing
  - How much to increment/decrement in pointer arithmetic
  
But the address itself is always the same size!
</code></pre>
<h3 id="pointer-arithmetic-depends-on-type"><a class="header" href="#pointer-arithmetic-depends-on-type">Pointer Arithmetic Depends on Type:</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

std::cout &lt;&lt; ptr &lt;&lt; std::endl;      // e.g., 0x1000
std::cout &lt;&lt; ptr + 1 &lt;&lt; std::endl;  // 0x1004 (increments by sizeof(int) = 4)

char* c_ptr = reinterpret_cast&lt;char*&gt;(arr);
std::cout &lt;&lt; c_ptr &lt;&lt; std::endl;      // 0x1000
std::cout &lt;&lt; c_ptr + 1 &lt;&lt; std::endl;  // 0x1001 (increments by sizeof(char) = 1)
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="6-arrays-and-pointers"><a class="header" href="#6-arrays-and-pointers">6. Arrays and Pointers</a></h2>
<h3 id="real-life-analogy-apartment-building"><a class="header" href="#real-life-analogy-apartment-building">Real-Life Analogy: Apartment Building</a></h3>
<p>Think of an array as an apartment building where:</p>
<ul>
<li>The <strong>building address</strong> is like the array name (constant, never changes)</li>
<li>Each <strong>apartment</strong> is an array element</li>
<li><strong>Apartment numbers</strong> (1, 2, 3...) are like array indices</li>
</ul>
<pre><code>Apartment Building:                  Array in Memory:
┌────────────────────────────┐      ┌────────────────────────────┐
│ "Sunset Towers"            │      │ int arr[5]                 │
│ Located at 100 Main St     │      │ Located at 0x1000          │
│ (Building address is FIXED)│      │ (Array name is FIXED)      │
│                            │      │                            │
│ Apt #1: John (age 25)      │      │ arr[0]: 10                 │
│ Apt #2: Mary (age 30)      │      │ arr[1]: 20                 │
│ Apt #3: Bob  (age 35)      │      │ arr[2]: 30                 │
│ Apt #4: Sue  (age 40)      │      │ arr[3]: 40                 │
│ Apt #5: Tom  (age 45)      │      │ arr[4]: 50                 │
└────────────────────────────┘      └────────────────────────────┘

Building Address: 100 Main St       Array Name: arr
  - CANNOT change to different        - CANNOT change to point to
    street address                      different memory location
  - It's a PERMANENT landmark         - It's a CONSTANT POINTER
  
Apartment #1 is at:                 First element at:
  100 Main St, Apt #1                 arr + 0 = 0x1000
  
Apartment #3 is at:                 Third element at:
  100 Main St, Apt #3                 arr + 2 = 0x1008
</code></pre>
<h3 id="why-array-names-are-constant"><a class="header" href="#why-array-names-are-constant">Why Array Names Are Constant:</a></h3>
<pre><code class="language-cpp">// Real Life                           // Code
int arr[5] = {10, 20, 30, 40, 50};    // Build "Sunset Towers" at 100 Main St

// You CAN: Change what's inside apartments
arr[0] = 100;                         // Renovate Apt #1

// You CAN: Get a notecard with building address
int* ptr = arr;                       // Write "100 Main St" on a note
ptr++;                                // Update note to "100 Main St, Apt #2"

// You CANNOT: Move the entire building!
// arr = arr + 1;  ❌ ERROR!            // Can't relocate Sunset Towers!
// arr++;          ❌ ERROR!            // Buildings don't move!

int other[3] = {1, 2, 3};             // Different building: "Oak Plaza"
// arr = other;    ❌ ERROR!            // Can't make Sunset Towers become Oak Plaza!
</code></pre>
<h3 id="pointer-vs-array-name"><a class="header" href="#pointer-vs-array-name">Pointer vs Array Name:</a></h3>
<pre><code>Scenario: You have two notecards

NOTECARD 1 (Array Name - "arr"):
┌─────────────────────────────────┐
│ "Sunset Towers is permanently   │
│  located at 100 Main Street"    │
│                                 │
│ ❌ You CANNOT erase this and     │
│    write a different address    │
│ ✓ You CAN visit any apartment   │
└─────────────────────────────────┘

NOTECARD 2 (Pointer - "ptr"):
┌─────────────────────────────────┐
│ "Current location: 100 Main St" │
│                                 │
│ ✓ You CAN erase and write:      │
│   "Current location: 456 Oak"   │
│ ✓ You CAN visit any apartment   │
└─────────────────────────────────┘
</code></pre>
<h3 id="arrays-and-pointers"><a class="header" href="#arrays-and-pointers">Arrays and Pointers</a></h3>
<h3 id="array-name-as-a-constant-pointer"><a class="header" href="#array-name-as-a-constant-pointer">Array Name as a Constant Pointer</a></h3>
<p>When you declare an array, the array name acts like a <strong>constant pointer</strong> to the first element.</p>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};

// arr is equivalent to &amp;arr[0]
std::cout &lt;&lt; "Array name (arr):        " &lt;&lt; arr &lt;&lt; std::endl;         // e.g., 0x1000
std::cout &lt;&lt; "Address of first elem:   " &lt;&lt; &amp;arr[0] &lt;&lt; std::endl;    // e.g., 0x1000
std::cout &lt;&lt; "First element (*arr):    " &lt;&lt; *arr &lt;&lt; std::endl;        // 10
std::cout &lt;&lt; "First element (arr[0]):  " &lt;&lt; arr[0] &lt;&lt; std::endl;      // 10
</code></pre>
<h3 id="memory-layout-of-arrays"><a class="header" href="#memory-layout-of-arrays">Memory Layout of Arrays:</a></h3>
<pre><code>Array: int arr[5] = {10, 20, 30, 40, 50};

Memory View:
┌─────────┬─────────┬─────────┬─────────┬─────────┐
│   10    │   20    │   30    │   40    │   50    │
└─────────┴─────────┴─────────┴─────────┴─────────┘
↑         ↑         ↑         ↑         ↑
0x1000    0x1004    0x1008    0x100C    0x1010
│
arr (points here, FIXED location)

arr[0] ≡ *(arr + 0) ≡ *arr
arr[1] ≡ *(arr + 1)
arr[2] ≡ *(arr + 2)
arr[3] ≡ *(arr + 3)
arr[4] ≡ *(arr + 4)
</code></pre>
<h3 id="array-vs-pointer-key-difference"><a class="header" href="#array-vs-pointer-key-difference">Array vs Pointer: Key Difference</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // ptr points to first element

// Similarities:
std::cout &lt;&lt; arr[2] &lt;&lt; std::endl;    // 30
std::cout &lt;&lt; ptr[2] &lt;&lt; std::endl;    // 30
std::cout &lt;&lt; *(arr + 2) &lt;&lt; std::endl; // 30
std::cout &lt;&lt; *(ptr + 2) &lt;&lt; std::endl; // 30

// KEY DIFFERENCE: arr is a CONSTANT POINTER
ptr = ptr + 1;     // OK: ptr can be reassigned
// arr = arr + 1;  // ERROR: arr is a constant pointer!

int another[3] = {1, 2, 3};
ptr = another;     // OK: ptr can point to different array
// arr = another;  // ERROR: Cannot reassign arr!
</code></pre>
<h3 id="why-array-name-is-a-constant-pointer"><a class="header" href="#why-array-name-is-a-constant-pointer">Why Array Name is a Constant Pointer:</a></h3>
<pre><code class="language-cpp">int arr[5] = {10, 20, 30, 40, 50};

// Think of arr as:
// int* const arr = &lt;address of first element&gt;;

// This is why you CAN:
*arr = 100;        // Modify the value at arr[0]
*(arr + 1) = 200;  // Modify the value at arr[1]

// But you CANNOT:
// arr = arr + 1;     // Change where arr points
// arr++;             // Increment arr
// int other[3];
// arr = other;       // Point arr to different array

// However, a pointer TO the array can be changed:
int* ptr = arr;
ptr++;             // OK: ptr now points to arr[1]
ptr = arr;         // OK: Reset ptr to point to arr[0]
</code></pre>
<h3 id="visualization"><a class="header" href="#visualization">Visualization:</a></h3>
<pre><code>Stack Memory:
┌─────────────────────────────────────┐
│  int arr[5] = {10, 20, 30, ...};    │
│  ┌────┬────┬────┬────┬────┐         │
│  │ 10 │ 20 │ 30 │ 40 │ 50 │         │
│  └────┴────┴────┴────┴────┘         │
│   ↑                                 │
│   │ arr (CONSTANT - can't change)   │
│   │                                 │
│  ┌┴──────┐                          │
│  │  ptr  │ (VARIABLE - can change)  │
│  └───────┘                          │
│   ↓                                 │
│  Can be reassigned to point         │
│  anywhere                           │
└─────────────────────────────────────┘
</code></pre>
<h3 id="dynamic-array-allocation"><a class="header" href="#dynamic-array-allocation">Dynamic Array Allocation</a></h3>
<p>Unlike static arrays, dynamically allocated arrays use pointers that CAN be reassigned.</p>
<h4 id="allocating-dynamic-arrays"><a class="header" href="#allocating-dynamic-arrays">Allocating Dynamic Arrays:</a></h4>
<pre><code class="language-cpp">// Allocate array of 5 integers
int* arr = new int[5];

// Initialize values
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
arr[4] = 50;

// Access like normal array
for (int i = 0; i &lt; 5; i++) {
    std::cout &lt;&lt; arr[i] &lt;&lt; " ";
}
std::cout &lt;&lt; std::endl;

// IMPORTANT: Must use delete[] for arrays
delete[] arr;
arr = nullptr;
</code></pre>
<h4 id="allocate-with-initialization"><a class="header" href="#allocate-with-initialization">Allocate with Initialization:</a></h4>
<pre><code class="language-cpp">// C++11 and later: Initialize with values
int* arr = new int[5]{10, 20, 30, 40, 50};

// Zero-initialize
int* zeros = new int[5]();  // All elements set to 0

// Default-initialize (garbage values for primitives)
int* uninitialized = new int[5];

// Cleanup
delete[] arr;
delete[] zeros;
delete[] uninitialized;
</code></pre>
<h4 id="dynamic-array-memory-layout"><a class="header" href="#dynamic-array-memory-layout">Dynamic Array Memory Layout:</a></h4>
<pre><code>Stack:                          Heap:
┌─────────────┐                ┌────┬────┬────┬────┬────┐
│  int* arr   │ ───────────────&gt;│ 10 │ 20 │ 30 │ 40 │ 50 │
│  (8 bytes)  │                └────┴────┴────┴────┴────┘
└─────────────┘                (20 bytes allocated)
     │
     │ Can be reassigned!
     ▼
┌────────────────┐
│ arr = new ...  │  OK: This is a regular pointer
└────────────────┘
</code></pre>
<h3 id="deallocating-arrays-delete-vs-delete"><a class="header" href="#deallocating-arrays-delete-vs-delete">Deallocating Arrays: delete vs delete[]</a></h3>
<p><strong>CRITICAL:</strong> Always use <code>delete[]</code> for arrays allocated with <code>new[]</code>.</p>
<pre><code class="language-cpp">// Single object
int* ptr = new int(42);
delete ptr;  // Correct: Use delete for single object

// Array
int* arr = new int[10];
delete[] arr;  // Correct: Use delete[] for arrays

// WRONG - Undefined Behavior:
int* arr2 = new int[10];
delete arr2;  // BUG: Should be delete[]
              // May corrupt heap, leak memory, or crash

int* ptr2 = new int(42);
delete[] ptr2;  // BUG: Should be delete
                // Undefined behavior
</code></pre>
<h4 id="why-delete-is-necessary"><a class="header" href="#why-delete-is-necessary">Why delete[] is Necessary:</a></h4>
<pre><code>When you use new[]:
┌────────────────────────────────────┐
│ [hidden size info] [10] [20] [30]  │
└────────────────────────────────────┘
         ↑              ↑
         │              └─ Your pointer points here
         └─ Compiler stores array size here

delete[] knows to:
1. Call destructor for each element (for objects)
2. Read the hidden size information
3. Deallocate the entire block

delete (wrong) will:
1. Call destructor only once
2. Deallocate wrong amount of memory
3. Cause undefined behavior
</code></pre>
<h4 id="example-with-objects"><a class="header" href="#example-with-objects">Example with Objects:</a></h4>
<pre><code class="language-cpp">class MyClass {
public:
    MyClass() { std::cout &lt;&lt; "Constructor" &lt;&lt; std::endl; }
    ~MyClass() { std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl; }
};

// Allocate array of objects
MyClass* arr = new MyClass[3];
// Output:
// Constructor
// Constructor
// Constructor

delete[] arr;  // Calls destructor for ALL 3 objects
// Output:
// Destructor
// Destructor
// Destructor

// If you mistakenly use delete instead of delete[]:
MyClass* arr2 = new MyClass[3];
delete arr2;  // BUG: Only calls destructor ONCE!
              // Other 2 objects not properly destroyed
</code></pre>
<h3 id="passing-arrays-to-functions"><a class="header" href="#passing-arrays-to-functions">Passing Arrays to Functions</a></h3>
<p>When you pass an array to a function, it <strong>decays to a pointer</strong>. The size information is lost!</p>
<h4 id="array-decay"><a class="header" href="#array-decay">Array Decay:</a></h4>
<pre><code class="language-cpp">void print_array(int arr[], int size) {  // arr[] decays to int*
    std::cout &lt;&lt; "Inside function, sizeof(arr): " &lt;&lt; sizeof(arr) &lt;&lt; std::endl;
    // Output: 8 (size of pointer, not array!)
    
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    std::cout &lt;&lt; "In main, sizeof(arr): " &lt;&lt; sizeof(arr) &lt;&lt; std::endl;
    // Output: 20 (5 elements × 4 bytes each)
    
    print_array(arr, 5);  // Must pass size separately!
    
    return 0;
}
</code></pre>
<h4 id="why-you-need-to-pass-size"><a class="header" href="#why-you-need-to-pass-size">Why You Need to Pass Size:</a></h4>
<pre><code>In main():
┌─────────────────────────────────────┐
│  int arr[5] = {10, 20, 30, 40, 50}; │
│                                     │
│  sizeof(arr) = 20 bytes             │
│  Compiler KNOWS it's 5 elements     │
└─────────────────────────────────────┘

When passed to function:
┌─────────────────────────────────────┐
│  void func(int arr[])               │
│                                     │
│  arr is now just int*               │
│  sizeof(arr) = 8 (pointer size)     │
│  No size information!               │
│  Could point to 1, 5, 100 elements  │
└─────────────────────────────────────┘

Solution: Pass size explicitly!
func(arr, 5);
</code></pre>
<h4 id="different-ways-to-pass-arrays"><a class="header" href="#different-ways-to-pass-arrays">Different Ways to Pass Arrays:</a></h4>
<pre><code class="language-cpp">// Method 1: Array notation (still decays to pointer)
void func1(int arr[], int size) {
    // arr is int*
}

// Method 2: Pointer notation (equivalent to method 1)
void func2(int* arr, int size) {
    // More honest about what it is
}

// Method 3: Reference to array (preserves size!)
void func3(int (&amp;arr)[5]) {
    // Size is part of type - no decay!
    // But only works for arrays of exactly 5 elements
    std::cout &lt;&lt; sizeof(arr) &lt;&lt; std::endl;  // 20 (actual array size)
}

// Method 4: Template (best for generic code)
template&lt;size_t N&gt;
void func4(int (&amp;arr)[N]) {
    // Works for any size array
    std::cout &lt;&lt; "Array size: " &lt;&lt; N &lt;&lt; std::endl;
}

// Method 5: Modern C++ - use std::array or std::vector
void func5(const std::vector&lt;int&gt;&amp; vec) {
    // vec.size() always available!
    for (size_t i = 0; i &lt; vec.size(); i++) {
        std::cout &lt;&lt; vec[i] &lt;&lt; " ";
    }
}

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    func1(arr, 5);           // OK
    func2(arr, 5);           // OK
    func3(arr);              // OK: size deduced from type
    func4(arr);              // OK: N = 5 automatically
    
    std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};
    func5(vec);              // Best: size is always known
    
    return 0;
}
</code></pre>
<h4 id="why-array-size-is-not-passed-automatically"><a class="header" href="#why-array-size-is-not-passed-automatically">Why Array Size is Not Passed Automatically:</a></h4>
<pre><code class="language-cpp">void mystery_function(int* arr) {
    // From the pointer alone, we cannot tell:
    // - Is this an array or single element?
    // - If array, how many elements?
    // - Where does it end?
    
    // This is dangerous:
    for (int i = 0; i &lt; 100; i++) {  // What if array has &lt; 100 elements?
        arr[i] = 0;  // Could write past array bounds!
    }
}

// Solution: Always pass size
void safe_function(int* arr, int size) {
    for (int i = 0; i &lt; size; i++) {
        arr[i] = 0;  // Safe: we know the bounds
    }
}
</code></pre>
<h3 id="multi-dimensional-arrays"><a class="header" href="#multi-dimensional-arrays">Multi-dimensional Arrays</a></h3>
<h4 id="static-multi-dimensional-arrays"><a class="header" href="#static-multi-dimensional-arrays">Static Multi-dimensional Arrays:</a></h4>
<pre><code class="language-cpp">int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// Memory layout is contiguous:
// [1][2][3][4][5][6][7][8][9][10][11][12]

std::cout &lt;&lt; matrix[1][2] &lt;&lt; std::endl;  // Output: 7
std::cout &lt;&lt; *(*(matrix + 1) + 2) &lt;&lt; std::endl;  // Also: 7
</code></pre>
<h4 id="dynamic-2d-arrays-method-1-array-of-pointers"><a class="header" href="#dynamic-2d-arrays-method-1-array-of-pointers">Dynamic 2D Arrays (Method 1: Array of Pointers):</a></h4>
<pre><code class="language-cpp">// Allocate array of pointers
int** matrix = new int*[3];  // 3 rows

// Allocate each row
for (int i = 0; i &lt; 3; i++) {
    matrix[i] = new int[4];  // 4 columns
}

// Use it
matrix[1][2] = 42;

// Deallocate (must free in reverse order)
for (int i = 0; i &lt; 3; i++) {
    delete[] matrix[i];  // Free each row
}
delete[] matrix;  // Free array of pointers
</code></pre>
<p><strong>Memory Layout:</strong></p>
<pre><code>Stack:        Heap:
┌────────┐    ┌─────┐    ┌────┬────┬────┬────┐
│ matrix │───&gt;│ ptr │───&gt;│ 1  │ 2  │ 3  │ 4  │  Row 0
└────────┘    ├─────┤    └────┴────┴────┴────┘
              │ ptr │───&gt;┌────┬────┬────┬────┐
              ├─────┤    │ 5  │ 6  │ 7  │ 8  │  Row 1
              │ ptr │─┐  └────┴────┴────┴────┘
              └─────┘ │  ┌────┬────┬────┬────┐
                      └─&gt;│ 9  │ 10 │ 11 │ 12 │  Row 2
                         └────┴────┴────┴────┘
Not contiguous in memory!
</code></pre>
<h4 id="dynamic-2d-arrays-method-2-contiguous-memory"><a class="header" href="#dynamic-2d-arrays-method-2-contiguous-memory">Dynamic 2D Arrays (Method 2: Contiguous Memory):</a></h4>
<pre><code class="language-cpp">// Allocate as single block (better for cache performance)
int* matrix = new int[3 * 4];  // Total elements

// Access using index calculation: matrix[row * cols + col]
int rows = 3, cols = 4;
matrix[1 * cols + 2] = 42;  // matrix[1][2] = 42

// Helper function for cleaner access
auto at = [&amp;](int r, int c) -&gt; int&amp; {
    return matrix[r * cols + c];
};

at(1, 2) = 42;

// Cleanup is simple
delete[] matrix;
</code></pre>
<p><strong>Memory Layout:</strong></p>
<pre><code>Contiguous block in heap:
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 10 │ 11 │ 12 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
 └─── Row 0 ───┘ └─── Row 1 ───┘ └─── Row 2 ───┘

Access: matrix[row * num_cols + col]
</code></pre>
<h3 id="summary-table-arrays-vs-pointers"><a class="header" href="#summary-table-arrays-vs-pointers">Summary Table: Arrays vs Pointers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Static Array</th><th>Dynamic Array</th><th>Pointer</th></tr></thead><tbody>
<tr><td>Declaration</td><td><code>int arr[5]</code></td><td><code>int* arr = new int[5]</code></td><td><code>int* ptr</code></td></tr>
<tr><td>Size known at compile-time</td><td>✓ Yes</td><td>✗ No</td><td>✗ No</td></tr>
<tr><td>Can be reassigned</td><td>✗ No (constant pointer)</td><td>✓ Yes</td><td>✓ Yes</td></tr>
<tr><td>Stored on</td><td>Stack</td><td>Heap</td><td>Stack (pointer itself)</td></tr>
<tr><td>Automatic cleanup</td><td>✓ Yes</td><td>✗ No (need delete[])</td><td>✗ No</td></tr>
<tr><td>Sizeof gives</td><td>Array size</td><td>Pointer size</td><td>Pointer size</td></tr>
<tr><td>Passed to function</td><td>Decays to pointer</td><td>Already pointer</td><td>Pointer</td></tr>
</tbody></table>
</div>
<h3 id="best-practices-for-arrays"><a class="header" href="#best-practices-for-arrays">Best Practices for Arrays:</a></h3>
<pre><code class="language-cpp">// ❌ Avoid: C-style arrays for new code
int arr[100];

// ✅ Prefer: std::array (fixed size)
#include &lt;array&gt;
std::array&lt;int, 100&gt; arr;  // Size is part of type
arr.size();  // Always available

// ✅ Prefer: std::vector (dynamic size)
#include &lt;vector&gt;
std::vector&lt;int&gt; vec(100);  // Dynamic, resizable
vec.size();  // Always available
vec.push_back(42);  // Can grow

// ✅ For passing arrays to functions
void process(const std::vector&lt;int&gt;&amp; data) {
    // Size is always available via data.size()
}

// ✅ For 2D data
std::vector&lt;std::vector&lt;int&gt;&gt; matrix(rows, std::vector&lt;int&gt;(cols));
// Or for better performance:
std::vector&lt;int&gt; matrix(rows * cols);
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="7-const-pointers-variations"><a class="header" href="#7-const-pointers-variations">7. Const Pointers Variations</a></h2>
<p>There are three types of const pointer declarations, each with different meanings.</p>
<h3 id="1-pointer-to-constant-const-t-or-t-const"><a class="header" href="#1-pointer-to-constant-const-t-or-t-const">1. Pointer to Constant (<code>const T*</code> or <code>T const*</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
const int* ptr = &amp;value;  // Pointer to constant int

// *ptr = 100;  // ERROR: Cannot modify the value through ptr
value = 100;    // OK: Can modify value directly

int another = 50;
ptr = &amp;another; // OK: Can change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│  value = 42  │ ← Can't modify via ptr
└──────────────┘
      ↑
      │ (can change this pointer)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="2-constant-pointer-t-const"><a class="header" href="#2-constant-pointer-t-const">2. Constant Pointer (<code>T* const</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
int* const ptr = &amp;value;  // Constant pointer to int

*ptr = 100;     // OK: Can modify the value
// ptr = &amp;another; // ERROR: Cannot change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│ value = 100  │ ← Can modify via ptr
└──────────────┘
      ↑
      │ (FIXED - cannot change)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="3-constant-pointer-to-constant-const-t-const"><a class="header" href="#3-constant-pointer-to-constant-const-t-const">3. Constant Pointer to Constant (<code>const T* const</code>)</a></h3>
<pre><code class="language-cpp">int value = 42;
const int* const ptr = &amp;value;  // Constant pointer to constant int

// *ptr = 100;     // ERROR: Cannot modify the value
// ptr = &amp;another; // ERROR: Cannot change where ptr points
</code></pre>
<p><strong>Memory View:</strong></p>
<pre><code>┌──────────────┐
│  value = 42  │ ← Can't modify via ptr
└──────────────┘
      ↑
      │ (FIXED - cannot change)
   ┌──┴──┐
   │ ptr │
   └─────┘
</code></pre>
<h3 id="summary-table"><a class="header" href="#summary-table">Summary Table:</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Declaration</th><th>Can Modify Value?</th><th>Can Change Pointer?</th><th>Read as</th></tr></thead><tbody>
<tr><td><code>int* ptr</code></td><td>✓ Yes</td><td>✓ Yes</td><td>Pointer to int</td></tr>
<tr><td><code>const int* ptr</code></td><td>✗ No</td><td>✓ Yes</td><td>Pointer to const int</td></tr>
<tr><td><code>int* const ptr</code></td><td>✓ Yes</td><td>✗ No</td><td>Const pointer to int</td></tr>
<tr><td><code>const int* const ptr</code></td><td>✗ No</td><td>✗ No</td><td>Const pointer to const int</td></tr>
</tbody></table>
</div>
<h3 id="mnemonic-read-right-to-left"><a class="header" href="#mnemonic-read-right-to-left">Mnemonic: Read Right to Left</a></h3>
<pre><code class="language-cpp">const int* ptr;        // ptr is a pointer to const int
int* const ptr;        // ptr is a const pointer to int
const int* const ptr;  // ptr is a const pointer to const int
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="8-breaking-constantness-the-hack"><a class="header" href="#8-breaking-constantness-the-hack">8. Breaking Constantness (The Hack)</a></h2>
<p>While <code>const</code> is meant to protect data, C++ provides ways to remove const-ness. <strong>Use with extreme caution!</strong></p>
<h3 id="using-const_cast"><a class="header" href="#using-const_cast">Using <code>const_cast</code></a></h3>
<pre><code class="language-cpp">const int value = 42;
const int* const_ptr = &amp;value;

// Remove const using const_cast
int* mutable_ptr = const_cast&lt;int*&gt;(const_ptr);
*mutable_ptr = 100;  // Undefined Behavior if value was truly const!

std::cout &lt;&lt; value &lt;&lt; std::endl;  // May still print 42 due to optimization
std::cout &lt;&lt; *mutable_ptr &lt;&lt; std::endl;  // May print 100
</code></pre>
<h3 id="why-this-is-dangerous"><a class="header" href="#why-this-is-dangerous">Why This Is Dangerous:</a></h3>
<pre><code class="language-cpp">// Case 1: Originally non-const (OK)
int x = 42;
const int* ptr = &amp;x;
int* mutable_ptr = const_cast&lt;int*&gt;(ptr);
*mutable_ptr = 100;  // OK: x was not const originally

// Case 2: Originally const (UNDEFINED BEHAVIOR)
const int y = 42;
const int* ptr2 = &amp;y;
int* mutable_ptr2 = const_cast&lt;int*&gt;(ptr2);
*mutable_ptr2 = 100;  // UNDEFINED BEHAVIOR! Compiler may have optimized assuming y never changes
</code></pre>
<h3 id="compiler-optimizations-can-break-your-code"><a class="header" href="#compiler-optimizations-can-break-your-code">Compiler Optimizations Can Break Your Code:</a></h3>
<pre><code class="language-cpp">const int value = 42;

// Compiler might replace all uses of 'value' with literal 42
if (value == 42) {
    std::cout &lt;&lt; "Always true!" &lt;&lt; std::endl;
}

// Even if you modify via const_cast, the if statement
// might still use the literal 42 due to optimization!
</code></pre>
<h3 id="legitimate-use-case"><a class="header" href="#legitimate-use-case">Legitimate Use Case:</a></h3>
<pre><code class="language-cpp">// Working with legacy C APIs that don't use const correctly
void legacy_function(char* str);  // Doesn't modify str, but signature is wrong

void modern_code() {
    const char* message = "Hello";
    // We know legacy_function won't modify str
    legacy_function(const_cast&lt;char*&gt;(message));  // Acceptable if you're sure
}
</code></pre>
<h3 id="other-ways-to-break-const-all-bad"><a class="header" href="#other-ways-to-break-const-all-bad">Other Ways to Break Const (All bad):</a></h3>
<pre><code class="language-cpp">const int value = 42;

// Method 1: C-style cast (discouraged)
int* ptr1 = (int*)&amp;value;

// Method 2: reinterpret_cast (very dangerous)
int* ptr2 = reinterpret_cast&lt;int*&gt;(const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(&amp;value)));

// Method 3: memcpy (also undefined behavior)
int copy;
memcpy(&amp;copy, &amp;value, sizeof(int));
copy = 100;
memcpy(const_cast&lt;int*&gt;(&amp;value), &amp;copy, sizeof(int));
</code></pre>
<p><strong>Bottom Line:</strong> If you're using <code>const_cast</code>, you're probably doing something wrong. Reconsider your design.</p>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="9-placement-new-operator"><a class="header" href="#9-placement-new-operator">9. Placement New Operator</a></h2>
<p>Placement new constructs an object at a <strong>pre-allocated memory address</strong> without allocating new memory.</p>
<h3 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax:</a></h3>
<pre><code class="language-cpp">#include &lt;new&gt;  // Required for placement new

// Allocate raw memory buffer
char buffer[sizeof(int)];

// Construct an int at the buffer location
int* ptr = new (buffer) int(42);  // Placement new

std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  // Output: 42

// Must manually call destructor (no delete needed for placement new)
ptr-&gt;~int();  // Destructor call (trivial for int, but important for classes)
</code></pre>
<h3 id="complex-example-with-classes"><a class="header" href="#complex-example-with-classes">Complex Example with Classes:</a></h3>
<pre><code class="language-cpp">class MyClass {
public:
    int x;
    double y;
    
    MyClass(int x_val, double y_val) : x(x_val), y(y_val) {
        std::cout &lt;&lt; "Constructor called" &lt;&lt; std::endl;
    }
    
    ~MyClass() {
        std::cout &lt;&lt; "Destructor called" &lt;&lt; std::endl;
    }
};

// Pre-allocate memory
alignas(MyClass) char buffer[sizeof(MyClass)];

// Construct object in buffer
MyClass* obj = new (buffer) MyClass(10, 3.14);

std::cout &lt;&lt; "x: " &lt;&lt; obj-&gt;x &lt;&lt; ", y: " &lt;&lt; obj-&gt;y &lt;&lt; std::endl;

// Must manually call destructor
obj-&gt;~MyClass();

// No delete needed - we didn't allocate memory with new
</code></pre>
<h3 id="memory-diagram"><a class="header" href="#memory-diagram">Memory Diagram:</a></h3>
<pre><code>Regular new:
┌────────────────────────────────────┐
│ new MyClass(10, 3.14)              │
├────────────────────────────────────┤
│ 1. Allocate memory (heap)          │
│ 2. Construct object in that memory │
│ 3. Return pointer                  │
└────────────────────────────────────┘

Placement new:
┌────────────────────────────────────┐
│ char buffer[sizeof(MyClass)];      │ ← Memory already exists
│ new (buffer) MyClass(10, 3.14);    │
├────────────────────────────────────┤
│ 1. Use provided address (buffer)   │
│ 2. Construct object there          │
│ 3. Return pointer                  │
└────────────────────────────────────┘
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases:</a></h3>
<h4 id="1-memory-pools"><a class="header" href="#1-memory-pools">1. Memory Pools</a></h4>
<pre><code class="language-cpp">// Pre-allocate a pool of memory
const size_t POOL_SIZE = 1024;
char memory_pool[POOL_SIZE];
size_t offset = 0;

// Allocate objects from the pool
MyClass* obj1 = new (memory_pool + offset) MyClass(1, 1.1);
offset += sizeof(MyClass);

MyClass* obj2 = new (memory_pool + offset) MyClass(2, 2.2);
offset += sizeof(MyClass);

// Cleanup
obj1-&gt;~MyClass();
obj2-&gt;~MyClass();
</code></pre>
<h4 id="2-reconstructing-objects-in-place"><a class="header" href="#2-reconstructing-objects-in-place">2. Reconstructing Objects In-Place</a></h4>
<pre><code class="language-cpp">MyClass* obj = new MyClass(10, 3.14);

// Destroy and reconstruct with new values
obj-&gt;~MyClass();
new (obj) MyClass(20, 6.28);  // Reuse same memory

delete obj;  // Now delete is OK because original memory was from new
</code></pre>
<h4 id="3-custom-allocators-stdvector-etc"><a class="header" href="#3-custom-allocators-stdvector-etc">3. Custom Allocators (std::vector, etc.)</a></h4>
<pre><code class="language-cpp">template&lt;typename T&gt;
class CustomAllocator {
public:
    void construct(T* ptr, const T&amp; value) {
        new (ptr) T(value);  // Placement new
    }
    
    void destroy(T* ptr) {
        ptr-&gt;~T();  // Manual destructor call
    }
};
</code></pre>
<h3 id="important-rules"><a class="header" href="#important-rules">Important Rules:</a></h3>
<ol>
<li><strong>Never delete placement new memory</strong> unless the original memory was allocated with regular new</li>
<li><strong>Always call destructor manually</strong> for non-trivial types</li>
<li><strong>Ensure proper alignment</strong> using <code>alignas</code></li>
<li><strong>Be careful with memory lifetime</strong> - the buffer must outlive the object</li>
</ol>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="10-best-practices"><a class="header" href="#10-best-practices">10. Best Practices</a></h2>
<h3 id="1-always-initialize-pointers"><a class="header" href="#1-always-initialize-pointers">1. Always Initialize Pointers</a></h3>
<pre><code class="language-cpp">// Bad
int* ptr;  // Uninitialized - contains garbage

// Good
int* ptr = nullptr;  // Explicitly null
int* ptr2 = new int(42);  // Immediately initialized
</code></pre>
<h3 id="2-check-for-nullptr-before-dereferencing"><a class="header" href="#2-check-for-nullptr-before-dereferencing">2. Check for nullptr Before Dereferencing</a></h3>
<pre><code class="language-cpp">int* ptr = get_some_pointer();

if (ptr != nullptr) {
    *ptr = 100;  // Safe
}

// Or use modern syntax
if (ptr) {
    *ptr = 100;
}
</code></pre>
<h3 id="3-always-set-to-nullptr-after-delete"><a class="header" href="#3-always-set-to-nullptr-after-delete">3. Always Set to nullptr After delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Prevents dangling pointer

// Now safe to delete again (no-op)
delete ptr;  // OK: deleting nullptr is safe
</code></pre>
<h3 id="4-use-smart-pointers-modern-c--will-cover-in-detail-later"><a class="header" href="#4-use-smart-pointers-modern-c--will-cover-in-detail-later">4. Use Smart Pointers (Modern C++ : Will cover in detail later)</a></h3>
<pre><code class="language-cpp">#include &lt;memory&gt;

// Use unique_ptr for exclusive ownership
std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42);

// Use shared_ptr for shared ownership
std::shared_ptr&lt;int&gt; ptr2 = std::make_shared&lt;int&gt;(100);

// No need to delete - automatic cleanup!
</code></pre>
<h3 id="5-match-newdelete-and-newdelete"><a class="header" href="#5-match-newdelete-and-newdelete">5. Match new/delete and new[]/delete[]</a></h3>
<pre><code class="language-cpp">// Single object
int* ptr = new int;
delete ptr;  // Correct

// Array
int* arr = new int[10];
delete[] arr;  // Correct - must use delete[]

// WRONG combinations:
// int* ptr = new int;
// delete[] ptr;  // WRONG!

// int* arr = new int[10];
// delete arr;  // WRONG!
</code></pre>
<h3 id="6-avoid-raw-pointers-for-ownership"><a class="header" href="#6-avoid-raw-pointers-for-ownership">6. Avoid Raw Pointers for Ownership</a></h3>
<pre><code class="language-cpp">// Bad: Who owns this? Who deletes it?
int* create_resource() {
    return new int(42);
}

// Good: Clear ownership
std::unique_ptr&lt;int&gt; create_resource() {
    return std::make_unique&lt;int&gt;(42);
}
</code></pre>
<h3 id="7-use-references-when-you-dont-need-nullptr"><a class="header" href="#7-use-references-when-you-dont-need-nullptr">7. Use References When You Don't Need nullptr</a></h3>
<pre><code class="language-cpp">// If something must exist, use reference
void process(int&amp; value) {  // Cannot be null
    value = 42;
}

// Use pointer only if nullptr is meaningful
void process(int* value) {  // Can be null
    if (value) {
        *value = 42;
    }
}
</code></pre>
<h3 id="8-const-correctness"><a class="header" href="#8-const-correctness">8. Const Correctness</a></h3>
<pre><code class="language-cpp">// Promise not to modify through pointer
void read_only(const int* ptr) {
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
}

// Clear intent to modify
void modify(int* ptr) {
    *ptr = 100;
}
</code></pre>
<hr />
<h2 id="10-common-bugs"><a class="header" href="#10-common-bugs">10. Common Bugs</a></h2>
<h3 id="1-dangling-pointer"><a class="header" href="#1-dangling-pointer">1. Dangling Pointer</a></h3>
<pre><code class="language-cpp">int* create_dangling() {
    int x = 42;
    return &amp;x;  // BUG: x is destroyed when function returns
}

int* ptr = create_dangling();
*ptr = 100;  // Undefined behavior! Memory is invalid
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* create_safe() {
    int* ptr = new int(42);
    return ptr;  // OK: Memory persists
}

// Or better: use smart pointer
std::unique_ptr&lt;int&gt; create_safer() {
    return std::make_unique&lt;int&gt;(42);
}
</code></pre>
<h3 id="2-double-delete"><a class="header" href="#2-double-delete">2. Double Delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
delete ptr;  // BUG: Double delete - undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Set to null after delete
delete ptr;  // OK: Deleting nullptr is safe (no-op)
</code></pre>
<h3 id="3-memory-leak"><a class="header" href="#3-memory-leak">3. Memory Leak</a></h3>
<pre><code class="language-cpp">void leak_memory() {
    int* ptr = new int(42);
    // Forgot to delete!
}  // BUG: Memory is leaked

void leak_on_exception() {
    int* ptr = new int(42);
    some_function_that_throws();  // If this throws...
    delete ptr;  // ...this never executes - LEAK!
}
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">void no_leak() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
}  // Automatically cleaned up

void no_leak_on_exception() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
    some_function_that_throws();  // Even if this throws, ptr is cleaned up
}
</code></pre>
<h3 id="4-array-delete-mismatch"><a class="header" href="#4-array-delete-mismatch">4. Array Delete Mismatch</a></h3>
<pre><code class="language-cpp">int* arr = new int[10];
delete arr;  // BUG: Should be delete[]

int* ptr = new int;
delete[] ptr;  // BUG: Should be delete
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* arr = new int[10];
delete[] arr;  // Correct

// Or better: use std::vector
std::vector&lt;int&gt; arr(10);  // No manual delete needed
</code></pre>
<h3 id="5-using-after-delete"><a class="header" href="#5-using-after-delete">5. Using After Delete</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
*ptr = 100;  // BUG: Use after free - undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // Set to null

if (ptr) {
    *ptr = 100;  // Won't execute - safe
}
</code></pre>
<h3 id="6-lost-pointer"><a class="header" href="#6-lost-pointer">6. Lost Pointer</a></h3>
<pre><code class="language-cpp">int* ptr = new int(42);
ptr = new int(100);  // BUG: Lost reference to first allocation - LEAK!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = new int(42);
delete ptr;  // Clean up first
ptr = new int(100);

// Or use smart pointer
std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
ptr = std::make_unique&lt;int&gt;(100);  // Old memory automatically deleted
</code></pre>
<h3 id="7-null-pointer-dereference"><a class="header" href="#7-null-pointer-dereference">7. Null Pointer Dereference</a></h3>
<pre><code class="language-cpp">int* ptr = nullptr;
*ptr = 42;  // BUG: Dereferencing null pointer - crash!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;
if (ptr) {
    *ptr = 42;  // Safe
}

// Or use assert for debugging
#include &lt;cassert&gt;
assert(ptr != nullptr);
*ptr = 42;
</code></pre>
<h3 id="8-uninitialized-pointer"><a class="header" href="#8-uninitialized-pointer">8. Uninitialized Pointer</a></h3>
<pre><code class="language-cpp">int* ptr;  // Uninitialized - contains garbage
*ptr = 42;  // BUG: Writing to random memory!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int* ptr = nullptr;  // Always initialize
if (ptr) {
    *ptr = 42;
}

// Or initialize immediately
int* ptr = new int;
*ptr = 42;
</code></pre>
<h3 id="9-pointer-arithmetic-out-of-bounds"><a class="header" href="#9-pointer-arithmetic-out-of-bounds">9. Pointer Arithmetic Out of Bounds</a></h3>
<pre><code class="language-cpp">int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr += 10;  // BUG: Points outside array
*ptr = 100;  // Undefined behavior!
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

// Check bounds
if (ptr + 10 &lt; arr + 5) {
    ptr += 10;
    *ptr = 100;
}

// Or use std::vector with at()
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
try {
    vec.at(10) = 100;  // Throws exception if out of bounds
} catch (const std::out_of_range&amp; e) {
    std::cerr &lt;&lt; "Out of bounds!" &lt;&lt; std::endl;
}
</code></pre>
<h3 id="10-mixing-mallocfree-with-newdelete"><a class="header" href="#10-mixing-mallocfree-with-newdelete">10. Mixing malloc/free with new/delete</a></h3>
<pre><code class="language-cpp">int* ptr = (int*)malloc(sizeof(int));
delete ptr;  // BUG: Must use free()

int* ptr2 = new int;
free(ptr2);  // BUG: Must use delete
</code></pre>
<p><strong>Fix:</strong></p>
<pre><code class="language-cpp">// C-style
int* ptr = (int*)malloc(sizeof(int));
free(ptr);

// C++-style (preferred)
int* ptr2 = new int;
delete ptr2;
</code></pre>
<p><a href="#table-of-contents">↑ Back to Table of Contents</a></p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways:</a></h3>
<ol>
<li><strong>Pointers store memory addresses</strong>, not values</li>
<li><strong>Dereferencing accesses the value</strong> at the stored address</li>
<li><strong>Dynamic memory requires manual management</strong> (new/delete)</li>
<li><strong>All pointers are the same size</strong> regardless of type</li>
<li><strong>Const pointers have three variations</strong> with different restrictions</li>
<li><strong>Smart pointers are preferred</strong> in modern C++ for automatic memory management</li>
<li><strong>Always initialize pointers</strong> and check for nullptr</li>
<li><strong>Match allocation/deallocation methods</strong> (new/delete, new[]/delete[], malloc/free)</li>
</ol>
<h3 id="modern-c-recommendations"><a class="header" href="#modern-c-recommendations">Modern C++ Recommendations:</a></h3>
<ul>
<li>✅ Use <code>std::unique_ptr</code> and <code>std::shared_ptr</code></li>
<li>✅ Use <code>std::vector</code> instead of arrays</li>
<li>✅ Use references when ownership isn't involved</li>
<li>✅ Use RAII (Resource Acquisition Is Initialization) principles(Will cover later)</li>
<li>❌ Avoid raw pointers for ownership</li>
<li>❌ Avoid manual memory management when possible</li>
<li>❌ Avoid <code>const_cast</code> unless absolutely necessary</li>
</ul>
<hr />
<p><strong>Remember: With great pointer power comes great responsibility. 🎯</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3_storage_classes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="4_constrctor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3_storage_classes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="4_constrctor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
